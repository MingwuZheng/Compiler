//此printf不会自动在末尾输出\n换行符
//done by xjf on 2018/12/1

//全局变量将以下划线开头
//常量声明（单个<常量定义>组成<常量声明>，同一类别的多个常量共用一个类别标识符）
const int _t1 = 1, _t2 = 2, _t3 = 3;

//变量声明（单个<变量定义>组成<变量声明>，同一类别的多个变量共用一个类别标识符）
char _c1, _c2, _c3, _c4;


//<有/无返回值函数定义>： 四种类型（有无参数、有无返回值）的函数定义  ff1 ff2 ff3 ff4
//覆盖3种返回的形式（return ;  |   return (..);  |  无return语句 ）
//若有返回值，测试两种返回类型int char
//函数定义内的常量说明和变量说明
//参数表中参数个数：1个、多个(多于4个且类型多样)

//1.有返回值，char型，一个参数
char ff1(char c){
    const char temp_c = 'b';//函数定义内的常量说明
    _c1 = temp_c;//改变全局变量_c1的值
    return (c);//return (...);形式的返回语句
}

//2.有返回值，int型，无参
int ff2(){
    _c2 = '-';//改变全局变量_c2的值
    return (_t1+_t2+_t3);//return (...);形式的返回语句
}

//3.无返回值，>4个参数
void ff3(int a,int b,char c,int d,char e,char f){
    printf(a+b+c+d+e+f);
    return ;//有return语句，无返回值
}

//4.无返回值，无参
void ff4(){
    printf("_ff4_");
    //无return语句
}

//5.递归函数
int factorial(int a){
    int b;//函数定义内的变量说明
    if(a==1){
        return (1);
    }
    else{
        b = (factorial(a-1)*a);
        return (b);
    }
}

//6.常量变量的不同作用域
void ff5(){//小函数与全局常量变量的作用域分析
    const char _c2 = 'z';//与全局变量_c2同名
    
    int _t1;//与全局常量_t1同名
    _t1 = 4;
    
    printf(_t1 + _c2 + _c1);//调用之前_c1被改
}


//主函数
void main(){
    //主函数内的常量说明（多个<常量定义>组成<常量说明>，不同类别的常量）
    const int int_100 = 100;
    const char char_z = 'z';

    //主函数内的变量说明（多个<变量定义>组成<变量说明>，不同类别的常量，2种数组定义）
    //测试控制变量，包括： 1.基础点测试 2.中级测试 3.高级测试
    int in_1;
    
    //1.基础点测试 用的变量
    int t1,t2;
    char c1,c2,single_chars[10];
    int t3,t4,t5;
    int t6,t7,t8;
    int t9;
    char c3,c4;
    
    //2.中级测试 用的变量
    int t10,t11,t12,t13,t14,t15,t16,t17,t18,t19,t20,t21,t22,t23;
    char c5,c6,c7,c8;
    int t_array1[100];
    char c_array1[100];
    
    //3.高级测试 用的变量
    int _c4,i;
    char _t1;
    int t_array2[100];
    char c_array2[100];
    
    scanf(in_1);
    
    //1.基础点测试
    if(in_1==1){
        //1.测试scanf语句
        scanf(t1,c2,c1,t2);// 输入5 bc6
        
        //2.测试printf语句，3种形式，同时测试<字符串>，以及+-*/四则运算
        //2.1 printf'('<表达式>')'  且表达式为int型。 同时测试 +-*/四则运算
        printf(c2+t1*c2-t1/c1);//588
        //2.2 printf'('<字符串>')'，同时测试<字符串>中的全部合法字符，以及"不转义"现象
        printf("___ !#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~___\n\t\\\'___");
        printf("");//打印空字符串
        //2.3printf'('<字符串>,<表达式>')'  且表达式为char型
        printf("@@@@@",c2);//@@@@@b
        
        //3.测试<字符>
        single_chars[0] = '+';
        single_chars[1] = '-';
        single_chars[2] = '*';
        single_chars[3] = '/';
        single_chars[4] = '0';
        single_chars[5] = '9';
        single_chars[6] = 'a';
        single_chars[7] = 'z';
        single_chars[8] = 'A';
        single_chars[9] = 'Z';
        
        //4.测试比较运算符 6个。
        //思路：用全局的常量和变量 组合成3个数，然后对这3个数进行6中比较运算
        //首先，给要用的全局变量赋初值
        _c1 = '+';
        _c3 = 'a';
        //然后，组合成三个数，赋值给3个main的局部变量
        t3 = _c1 + _t2;     // t3 = 45
        t4 = - _c3 + 77;    // t4 = -20
        t5 = -1+'-'+1;    // t5 = 45
        if(t3 != t5)
            printf("error1");
        if(t3 == t4)
            printf("error2");
        if(t3 <= t4)
            printf("error3");
        if(t3 < t5)
            printf("error4");
        if(t4 >= t5)
            printf("error5");
        if(t5 > t3)
            printf("error6");
        //没有消息就是好消息
        
        //5.测试带前导0的<无符号整数>和<整数>
        t6 = 12;
        t7 = +23;
        t8 = -23;
        if(t8+t6+t7 != 12)
            printf("error7");
        
        //6.测试“不区分大小写”
        //6.1 识别关键字时，不应区分大小写。这里以if关键字为例
        if( 3 > 5 )
            printf("error8");
        //6.2 识别标识符时，不应区分大小写。这里考虑声明和使用的不同情况组合：(t9,T9) (C3,c3) (C4,C4)
        t9 = 9;
        c3 = '3';
        c4 = '4';
        if(c4-c3+t9 != 10)
            printf("error9");
    }
        
    
    //2.中级测试
    if(in_1==2){
        //0. int型和char型 数组元素的初始化，便于下面的使用
        t_array1[0] = 2333;
        c_array1[0] = '/';
        
        //1. 测试<因子>。看表达式只有一个因子的情况，考虑因子的多个情况
        t10 = ( -7 + +9 );  //'('<表达式>')'  
        
        c5 = '+';                 //<字符>
        c6 = c5;                //<标识符>--简单char变量
        c7 = c_array1[0];       //char型数组元素取值
        
        t11 = -7;               //<整数>
        t12 = t11;                //<标识符>--简单int变量
        t13 =  t_array1[0];     //int型数组元素取值
        
        t14 = ff2();               //<标识符>--无参有返回值int型函数调用  ff2函数返回常数6
        c8 = ff1('y');           //有参有返回值char型函数调用   ff1函数返回传入的char
        
        t14 = t10+c5+c6+c7+t11+t12+t13+t14+c8;
        // 2 + '+' + '+' + '/' + -7 + -7 + 2333 + 6 + 'y' = 2581
        
        //2. 测试<项>中有多个因子。一个表达式仅一个项
        printf(t11*-7*t13/c8/t10*t12);// -3304
        
        //3. 测试<表达式>中有多个项，表达式可选的[+|-]，以及字符参与运算时转化为int型
        printf(" ",+ +4+t14);//2585
        printf(" ",- +3/-2);//=1     ++4 --4  +-4  -+4 这一类的考察
        
        //4. if else 和 <条件>语句没有比较运算符
        // <条件>语句没有比较运算符, if else简单测试
        if(4/5)
            printf("error10");
        else
            t15 = 1;
        // if else 嵌套,  else与最近的if匹配
        if( 3 < 4 ){
            if( 4 < 4 )
                printf("error11");
            else if( 4 >= 4 ){
                if( t15 > 0 ) 
                    if( t15 < 0)
                        printf("error12");
                    else
                        printf(" ojbk");
            }
        }
        else{
            printf("error13");
        }        
        
        //5. while
        //执行 0,1,2,3次
        t16 = 1;
        t18 = 0;
		if(t16<=4){
			do{
				t17 = 1;
				if(t17<t16){
				do{
				    t18 = t18+t17;
				    t17 = t17+1;
				}while(t17<t16)}
				t16 = t16+1;
			}while(t16<=4);
		}
        //最后根据t18的值看是否正确
        //printf(" ",t18); //10
        
        //6. for 
        t19 = 0;
        //6.1 步长增. t20为循环控制变量2-5，使内层循环分别执行1,1,2,3次
        for(t20=2; t20<=5; t20=t20+1){
            t22 = 1;
            for(t21=2;t21<t20;t21=t21+2){
                t22 = t22*t21;
            }
            t19 = t19 + t22;
        }
        //t19 = 14
        //6.2 步长减. 执行1,1,2,3次
        for(t20=100; t20>=97; t20=t20-1){
            t22 = 1;
            for(t21=100;t21>t20;t21=t21-2){
                t22 = t22*t21;
            }
            t19 = t19 + t22;
        }
        //最后根据t19的值看是否正确
        //printf(" ",t19); // 10114
        
        //7. 空语句
        if( 1 > -0 ){
            ;;;;;
            ;;;;
            ;;;
            printf(" ojbk");
            ;;
            ;
        }
        
        //8.if for while等的的嵌套
        do{
            for(t23=0; t23<100; t23=t23+1){
                t23 = t23+2;
                if(t23>60){
                    printf(" ",t18+t19+t23);//10+10114+62 = 10186
                    return ;
                }    
            }
        }while(1)
        printf("error14");
    }
    
    
    //3.高级测试
    if(in_1==3){
        //1.递归函数
        printf(factorial(1)+factorial(2)+factorial(5));//123
        
        //2.测试语句中的<有返回值函数调用> <无返回值函数调用>（前面定义的4个函数的调用）
            //同时测试：分函数中是否能有效改变全局变量的值
        
        //2.1 有返回值有参数函数调用语句
        _c1 = 'a';
        ff1('+');//函数内部将全局变量_c1的值改为'b'
        printf(_c1); //注意不能：if(_c1 != 'b') ...
        
        //2.2 有返回值无参数函数调用语句
        _c2 = 'b';
        ff2();//函数内部将全局变量_c2的值改为'-'
        printf(_c2);
        
        //2.3 无返回值有参数函数调用语句
        ff3(1,2,'a',3,'b','c');//打印 传入的所有参数的和  //300
        
        //2.4 无返回值无参数函数调用语句
        ff4();//会打印字符串表示真的被调用
        
        
        //3. 作用域。同名变量的不同作用域
        _c1 = '*';
        ff5();//函数内有同名于全局变量的局部变量_c2  _t1，同时会使用全局变量的值  //打印出168
        
        //main函数内定义了同名于全局变量的 局部变量 _c2  _t1 且类型变化
        _c4 = 6666;
        _t1 = '8';
        printf(_c4+_t1);   //6722
        
        //4. 论坛上提醒的几个点
        //4.1 printf 打印字符数组，打印返回值为char型的函数，('r')
        c_array2[50] = 'h';
        printf(c_array2[50]); //'h'
        printf(ff1('g')); //'g'
        printf(('r')); //114
        
        //4.2 复杂表达式 作为 数组下标 或者 值参数值
        for(i=0; i<int_100; i=i+1)
            t_array2[i] = i;
        i = t_array2[t_array2[34/4*6+char_z/10]/23+t_array2[22*i/23*(t_array2[1]*1000)/1000+'9'/17]/30];
        // i =4
        printf(factorial(t_array2[t_array2[34/4*6+char_z/10]/23+t_array2[22*i/23*(t_array2[1]*1000)/1000+'9'/17]/30]) );
        // factorial(2) = 2
        
    }    
    
    return ;
}